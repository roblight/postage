<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Mobile Latency Monitor</title>
    <style>
      :root {
        --bg: #0f1720;
        --card: #0b1220;
        --accent: #4fd1c5;
        --muted: #9aa6b2;
        --danger: #ff6b6b;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
        background: linear-gradient(180deg, #071025 0%, #071826 100%);
        color: #e6eef6;
        padding: 16px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: stretch;
      }
      .container {
        max-width: 820px;
        margin: 0 auto;
        width: 100%;
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }
      h1 {
        font-size: 1.1rem;
        margin: 0;
      }
      .card {
        background: rgba(255, 255, 255, 0.02);
        border-radius: 12px;
        padding: 12px;
        margin-bottom: 12px;
        box-shadow: 0 6px 18px rgba(2, 6, 23, 0.6);
      }
      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      input[type="text"],
      input[type="number"],
      select {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.06);
        color: inherit;
        padding: 8px;
        border-radius: 8px;
        width: 100%;
        min-width: 140px;
      }
      .controls > * {
        flex: 1;
      }
      .small {
        flex: 0 0 120px;
      }
      button {
        background: var(--accent);
        color: #042026;
        border: none;
        padding: 10px 12px;
        border-radius: 8px;
        font-weight: 600;
      }
      button.secondary {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.06);
        color: var(--muted);
      }
      .stats {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
      }
      .stat {
        flex: 1 1 120px;
        background: rgba(255, 255, 255, 0.02);
        padding: 8px;
        border-radius: 8px;
        text-align: center;
      }
      .stat .label {
        font-size: 0.75rem;
        color: var(--muted);
      }
      .stat .value {
        font-weight: 700;
        font-size: 1.05rem;
      }
      canvas {
        width: 100%;
        height: 120px;
        border-radius: 8px;
        display: block;
      }
      footer {
        margin-top: auto;
        color: var(--muted);
        font-size: 0.85rem;
        text-align: center;
        padding: 8px;
      }
      @media (max-width: 520px) {
        .controls {
          flex-direction: column;
        }
        .small {
          flex: 1;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Mobile Latency Monitor</h1>
        <div style="font-size: 0.85rem; color: var(--muted)">
          Run on your phone • lightweight
        </div>
      </header>

      <div class="card">
        <div class="controls">
          <input
            id="target"
            type="text"
            value="https://www.google.com/generate_204"
            aria-label="target URL"
          />
          <input
            id="interval"
            type="number"
            class="small"
            value="2000"
            min="200"
            aria-label="interval ms"
          />
          <input
            id="timeout"
            type="number"
            class="small"
            value="3000"
            min="100"
            aria-label="timeout ms"
          />
          <button id="start">Start</button>
          <button id="clear" class="secondary">Clear</button>
        </div>
        <div class="stats" style="margin-top: 10px">
          <div class="stat">
            <div class="label">Last</div>
            <div id="last" class="value">— ms</div>
          </div>
          <div class="stat">
            <div class="label">Avg</div>
            <div id="avg" class="value">— ms</div>
          </div>
          <div class="stat">
            <div class="label">Min</div>
            <div id="min" class="value">— ms</div>
          </div>
          <div class="stat">
            <div class="label">Max</div>
            <div id="max" class="value">— ms</div>
          </div>
          <div class="stat">
            <div class="label">Jitter</div>
            <div id="jitter" class="value">— ms</div>
          </div>
          <div class="stat">
            <div class="label">Loss</div>
            <div id="loss" class="value">— %</div>
          </div>
          <div class="stat">
            <div class="label">Timeouts</div>
            <div id="timeouts" class="value">0</div>
          </div>
          <div class="stat">
            <div class="label">Errors</div>
            <div id="errors" class="value">0</div>
          </div>
        </div>
      </div>

      <div class="card">
        <canvas id="chart" width="800" height="120"></canvas>
        <div
          style="
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            color: var(--muted);
          "
        >
          <div id="samples">Samples: 0</div>
          <div id="connection">Connection: unknown</div>
        </div>
      </div>

      <footer class="card">
        Open this page from your mobile browser. For reliable results, serve
        from a local HTTP server and open via your phone's browser using your
        machine IP.
      </footer>
    </div>

    <script>
      // Simple mobile-friendly latency monitor using image-based pings (works cross-origin)
      const targetEl = document.getElementById("target");
      const intervalEl = document.getElementById("interval");
      const timeoutEl = document.getElementById("timeout");
      const startBtn = document.getElementById("start");
      const clearBtn = document.getElementById("clear");

      const lastEl = document.getElementById("last");
      const avgEl = document.getElementById("avg");
      const minEl = document.getElementById("min");
      const maxEl = document.getElementById("max");
      const jitterEl = document.getElementById("jitter");
      const lossEl = document.getElementById("loss");
      const timeoutsEl = document.getElementById("timeouts");
      const errorsEl = document.getElementById("errors");
      const samplesEl = document.getElementById("samples");
      const connectionEl = document.getElementById("connection");
      const canvas = document.getElementById("chart");
      const ctx = canvas.getContext("2d");

      let running = false;
      let timer = null;
      const history = []; // null for failed samples, number for ms
      const MAX_HISTORY = 120;

      function updateConnectionInfo() {
        const nav = navigator;
        const conn =
          nav.connection || nav.mozConnection || nav.webkitConnection;
        if (conn && conn.effectiveType) {
          connectionEl.textContent = `Connection: ${conn.effectiveType} (${
            conn.downlink || "—"
          } Mbps)`;
        } else {
          connectionEl.textContent = `Connection: unknown`;
        }
      }

      // Ping using fetch + AbortController for reliable timing and timeouts.
      // Using `mode: 'no-cors'` so cross-origin endpoints (like generate_204)
      // can be requested without CORS preflight; we only care about timing.
      function pingImage(url, timeout) {
        return new Promise(async (resolve, reject) => {
          const controller = new AbortController();
          const signal = controller.signal;
          const start = performance.now();
          const timer = setTimeout(() => {
            controller.abort();
          }, timeout);

          // Add cache-buster to avoid cached responses
          const sep = url.includes("?") ? "&" : "?";
          const u = url + sep + "_cache=" + Date.now();

          try {
            // `no-cors` makes the response opaque but the fetch promise still
            // resolves when the request completes. This gives a reliable timing
            // measurement for reachability and latency.
            await fetch(u, {
              method: "GET",
              mode: "no-cors",
              cache: "no-store",
              signal,
            });
            clearTimeout(timer);
            resolve(performance.now() - start);
          } catch (e) {
            clearTimeout(timer);
            if (e && e.name === "AbortError") reject(new Error("timeout"));
            else reject(new Error("error"));
          }
        });
      }

      function addSample(value) {
        history.push(value);
        if (history.length > MAX_HISTORY) history.shift();
        renderStats();
        drawChart();
      }

      function renderStats() {
        const attempts = history.length;
        const successes = history.filter((v) => typeof v === "number");
        const failures = attempts - successes.length;

        const timeouts = history.filter((v) => v === "timeout").length;
        const errors = history.filter((v) => v === "error").length;

        samplesEl.textContent = `Samples: ${attempts}`;
        lastEl.textContent = successes.length
          ? `${Math.round(successes[successes.length - 1])} ms`
          : "— ms";
        if (successes.length) {
          const min = Math.round(Math.min(...successes));
          const max = Math.round(Math.max(...successes));
          const avg = Math.round(
            successes.reduce((a, b) => a + b, 0) / successes.length
          );
          minEl.textContent = `${min} ms`;
          maxEl.textContent = `${max} ms`;
          avgEl.textContent = `${avg} ms`;
          // jitter: mean absolute difference between consecutive successes
          let diffs = 0,
            count = 0;
          for (let i = 1; i < successes.length; i++) {
            diffs += Math.abs(successes[i] - successes[i - 1]);
            count++;
          }
          const jitter = count ? Math.round(diffs / count) : 0;
          jitterEl.textContent = `${jitter} ms`;
        } else {
          minEl.textContent = "— ms";
          maxEl.textContent = "— ms";
          avgEl.textContent = "— ms";
          jitterEl.textContent = "— ms";
        }

        const loss = attempts ? Math.round((failures / attempts) * 100) : 0;
        lossEl.textContent = `${loss} %`;
        timeoutsEl.textContent = `${timeouts}`;
        errorsEl.textContent = `${errors}`;
      }

      function drawChart() {
        const w = (canvas.width = canvas.clientWidth * devicePixelRatio);
        const h = (canvas.height = canvas.clientHeight * devicePixelRatio);
        ctx.clearRect(0, 0, w, h);
        ctx.scale(devicePixelRatio, devicePixelRatio);
        const cw = canvas.clientWidth,
          ch = canvas.clientHeight;

        // background
        ctx.fillStyle = "rgba(255,255,255,0.02)";
        roundRect(ctx, 0, 0, cw, ch, 8);
        ctx.fill();

        const samples = history.slice(-MAX_HISTORY);
        const values = samples.filter((v) => typeof v === "number");
        const max = values.length ? Math.max(...values) : 1000;
        const min = values.length ? Math.min(...values) : 0;
        const range = Math.max(1, max - min);

        const padding = 6;
        const plotW = cw - padding * 2;
        const plotH = ch - padding * 2 - 10;

        ctx.beginPath();
        let first = true;
        const step = plotW / Math.max(1, samples.length - 1);
        for (let i = 0; i < samples.length; i++) {
          const x = padding + i * step;
          const v = samples[i];
          let y;
          if (typeof v !== "number") y = padding + plotH;
          else y = padding + (1 - (v - min) / range) * plotH;
          if (first) {
            ctx.moveTo(x, y);
            first = false;
          } else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = "#4fd1c5";
        ctx.lineWidth = 2;
        ctx.stroke();

        // draw failure markers (timeout vs error)
        for (let i = 0; i < samples.length; i++) {
          if (typeof samples[i] !== "number") {
            const x = padding + i * step;
            const y = padding + plotH;
            const v = samples[i];
            // timeout: orange-ish, error: red
            if (v === "timeout") ctx.fillStyle = "rgba(255,181,107,0.95)";
            else ctx.fillStyle = "rgba(255,107,107,0.95)";
            ctx.beginPath();
            ctx.arc(x, y - 6, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      function roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
      }

      async function singlePing() {
        const url = (targetEl.value || "").trim();
        if (!url) return null;
        const timeout = Math.max(50, Number(timeoutEl.value) || 3000);
        try {
          const ms = await pingImage(url, timeout);
          return ms;
        } catch (e) {
          // return a typed failure so UI can distinguish timeouts vs other errors
          if (e && e.message === "timeout") return "timeout";
          return "error"; // treat other errors as generic errors
        }
      }

      async function loopPing() {
        if (!running) return;
        updateConnectionInfo();
        const res = await singlePing();
        addSample(res);
        const interval = Math.max(100, Number(intervalEl.value) || 2000);
        timer = setTimeout(loopPing, interval);
      }

      startBtn.addEventListener("click", () => {
        if (running) {
          running = false;
          startBtn.textContent = "Start";
          if (timer) clearTimeout(timer);
          return;
        }
        // start
        history.length = 0;
        renderStats();
        drawChart();
        running = true;
        startBtn.textContent = "Stop";
        loopPing();
      });

      clearBtn.addEventListener("click", () => {
        history.length = 0;
        renderStats();
        drawChart();
      });

      // initial draw
      renderStats();
      drawChart();
      updateConnectionInfo();
      // keep connection info updated if available
      const nav = navigator;
      const conn = nav.connection || nav.mozConnection || nav.webkitConnection;
      if (conn && conn.addEventListener) {
        conn.addEventListener("change", updateConnectionInfo);
      }

      // resize handling
      let resizeTO;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTO);
        resizeTO = setTimeout(() => drawChart(), 120);
      });
    </script>
  </body>
</html>
