<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Mobile Latency Monitor</title>
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#071025" />
    <link rel="icon" type="image/png" href="/icons/icon-192.png" />
    <link rel="apple-touch-icon" href="/icons/icon-192.png" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <style>
      :root {
        --bg: #0f1720;
        --card: #0b1220;
        --accent: #4fd1c5;
        --muted: #9aa6b2;
        --danger: #ff6b6b;
      }
      html,
      body {
        min-height: 100vh;
        margin: 0;
      }
      body {
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
        background: linear-gradient(180deg, #071025 0%, #071826 100%);
        color: #e6eef6;
        padding: 16px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: stretch;
      }
      .container {
        max-width: 820px;
        margin: 0 auto;
        width: 100%;
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }
      h1 {
        font-size: 1.1rem;
        margin: 0;
      }
      .card {
        background: rgba(255, 255, 255, 0.02);
        border-radius: 12px;
        padding: 12px;
        margin-bottom: 12px;
        box-shadow: 0 6px 18px rgba(2, 6, 23, 0.6);
      }
      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      input[type="text"],
      input[type="number"],
      select {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.06);
        color: inherit;
        padding: 8px;
        border-radius: 8px;
        width: 100%;
        min-width: 140px;
      }
      .controls > * {
        flex: 1;
      }
      .small {
        flex: 0 0 120px;
      }
      button {
        background: var(--accent);
        color: #042026;
        border: none;
        padding: 10px 12px;
        border-radius: 8px;
        font-weight: 600;
      }
      button.secondary {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.06);
        color: var(--muted);
      }
      /* Ping activity indicator */
      .activity {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.06);
        flex: 0 0 auto;
        margin-left: 8px;
        align-self: center;
        transition: transform 150ms ease, background-color 150ms ease,
          box-shadow 300ms ease;
      }
      .activity.pending {
        background: var(--accent);
        animation: pulse 1200ms infinite;
        transform: scale(1.05);
      }
      .activity.success {
        background: rgba(76, 249, 184, 0.95);
        transform: scale(1.2);
        box-shadow: 0 6px 18px rgba(76, 249, 184, 0.12);
      }
      .activity.timeout {
        background: rgba(255, 181, 107, 0.95);
        transform: scale(1.15);
        box-shadow: 0 6px 18px rgba(255, 181, 107, 0.12);
      }
      .activity.error {
        background: rgba(255, 107, 107, 0.95);
        transform: scale(1.15);
        box-shadow: 0 6px 18px rgba(255, 107, 107, 0.12);
      }
      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(79, 209, 197, 0.35);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(79, 209, 197, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(79, 209, 197, 0);
        }
      }
      .stats {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
      }
      .stat {
        flex: 1 1 120px;
        background: rgba(255, 255, 255, 0.02);
        padding: 8px;
        border-radius: 8px;
        text-align: center;
      }
      .stat .label {
        font-size: 0.75rem;
        color: var(--muted);
      }
      .stat .value {
        font-weight: 700;
        font-size: 1.05rem;
      }
      canvas {
        width: 100%;
        height: 120px;
        border-radius: 8px;
        display: block;
      }
      footer {
        margin-top: auto;
        color: var(--muted);
        font-size: 0.85rem;
        text-align: center;
        padding: 8px;
      }
      @media (max-width: 520px) {
        .controls {
          flex-direction: column;
        }
        .small {
          flex: 1;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Mobile Latency Monitor</h1>
      </header>

      <div class="card">
        <div class="controls">
          <input
            id="target"
            type="text"
            value="https://www.google.com/generate_204"
            aria-label="target URL"
          />
          <input
            id="interval"
            type="number"
            class="small"
            value="2000"
            min="200"
            aria-label="interval ms"
          />
          <input
            id="timeout"
            type="number"
            class="small"
            value="3000"
            min="100"
            aria-label="timeout ms"
          />
          <button id="start">Start</button>
          <button id="clear" class="secondary">Clear</button>
          <div
            id="activity"
            class="activity"
            aria-hidden="true"
            title="Ping activity"
          ></div>
        </div>
        <div class="stats" style="margin-top: 10px">
          <div class="stat">
            <div class="label">Last</div>
            <div id="last" class="value">â€” ms</div>
          </div>
          <div class="stat">
            <div class="label">Avg</div>
            <div id="avg" class="value">â€” ms</div>
          </div>
          <div class="stat">
            <div class="label">Min</div>
            <div id="min" class="value">â€” ms</div>
          </div>
          <div class="stat">
            <div class="label">Max</div>
            <div id="max" class="value">â€” ms</div>
          </div>
          <div class="stat">
            <div class="label">Jitter</div>
            <div id="jitter" class="value">â€” ms</div>
          </div>
          <div class="stat">
            <div class="label">Loss</div>
            <div id="loss" class="value">â€” %</div>
          </div>
          <div class="stat">
            <div class="label">Timeouts</div>
            <div id="timeouts" class="value">0</div>
          </div>
          <div class="stat">
            <div class="label">Errors</div>
            <div id="errors" class="value">0</div>
          </div>
        </div>
      </div>

      <div class="card">
        <canvas id="chart" width="800" height="120"></canvas>
        <div
          style="display: flex; justify-content: space-between; margin-top: 8px"
        >
          <div id="connection">Connection: ðŸ¤·</div>
        </div>
      </div>
      <div class="card">
        <div id="map" style="height: 240px; border-radius: 8px"></div>
      </div>
    </div>

    <script>
      // Simple mobile-friendly latency monitor using image-based pings (works cross-origin)
      const targetEl = document.getElementById("target");
      const intervalEl = document.getElementById("interval");
      const timeoutEl = document.getElementById("timeout");
      const startBtn = document.getElementById("start");
      const clearBtn = document.getElementById("clear");

      const lastEl = document.getElementById("last");
      const avgEl = document.getElementById("avg");
      const minEl = document.getElementById("min");
      const maxEl = document.getElementById("max");
      const jitterEl = document.getElementById("jitter");
      const lossEl = document.getElementById("loss");
      const timeoutsEl = document.getElementById("timeouts");
      const errorsEl = document.getElementById("errors");
      const connectionEl = document.getElementById("connection");
      const canvas = document.getElementById("chart");
      const ctx = canvas.getContext("2d");

      // Activity indicator element and helper
      const activityEl = document.getElementById("activity");
      let _activityTimer = null;
      // lastActivityState is used by the map track to color segments
      let lastActivityState = null;
      let lastActivityTimestamp = null;
      function setActivity(state) {
        if (!activityEl) return;
        // record last state and timestamp for mapping
        lastActivityState = state || null;
        if (state) lastActivityTimestamp = Date.now();
        activityEl.className = "activity" + (state ? " " + state : "");
        if (_activityTimer) {
          clearTimeout(_activityTimer);
          _activityTimer = null;
        }
        // For transient states, revert to idle after a short delay
        if (state === "success" || state === "timeout" || state === "error") {
          _activityTimer = setTimeout(() => {
            if (activityEl) activityEl.className = "activity";
            _activityTimer = null;
            lastActivityState = null;
          }, 700);
        }
      }

      let running = false;
      let timer = null;
      const history = []; // null for failed samples, number for ms
      const MAX_HISTORY = 120;

      // Try to gather local IPs (via WebRTC) and public IP + PTR (via DoH).
      // NOTE: Browsers limit exposure of local IPs and reverse DNS for privacy.
      function getLocalIPs(timeout = 1000) {
        return new Promise((resolve) => {
          const ips = new Set();
          if (!window.RTCPeerConnection) return resolve([]);
          const pc = new RTCPeerConnection({ iceServers: [] });
          try {
            pc.createDataChannel("");
          } catch (e) {}
          pc.onicecandidate = (e) => {
            if (!e.candidate) {
              try {
                pc.close();
              } catch (err) {}
              resolve([...ips]);
              return;
            }
            const s = e.candidate.candidate;
            const re = /([0-9]{1,3}(?:\.[0-9]{1,3}){3})/g;
            let m;
            while ((m = re.exec(s))) ips.add(m[1]);
          };
          pc.createOffer()
            .then((offer) => pc.setLocalDescription(offer))
            .catch(() => {});
          setTimeout(() => {
            try {
              pc.close();
            } catch (e) {}
            resolve([...ips]);
          }, timeout);
        });
      }

      async function getPublicIP() {
        try {
          const res = await fetch("https://api.ipify.org?format=json");
          if (!res.ok) return null;
          const j = await res.json();
          return j.ip;
        } catch (e) {
          return null;
        }
      }

      // Reverse DNS for IPv4 using Cloudflare DoH (best-effort). Returns hostname or null.
      async function reverseDNS(ip) {
        if (!ip || ip.includes(":")) return null;
        const ptr = ip.split(".").reverse().join(".") + ".in-addr.arpa";
        const url =
          "https://cloudflare-dns.com/dns-query?name=" +
          encodeURIComponent(ptr) +
          "&type=PTR";
        try {
          const res = await fetch(url, {
            headers: { Accept: "application/dns-json" },
          });
          if (!res.ok) return null;
          const j = await res.json();
          if (j && j.Answer && j.Answer.length) {
            return j.Answer[0].data.replace(/\.$/, "");
          }
        } catch (e) {}
        return null;
      }

      // Update the connection UI with effectiveType/downlink + local/public info.
      async function updateConnectionInfo() {
        const nav = navigator;
        const conn =
          nav.connection || nav.mozConnection || nav.webkitConnection;
        const parts = [];
        if (conn && conn.effectiveType) {
          const downlink = Number.isFinite(conn.downlink)
            ? conn.downlink.toFixed(1)
            : "â€”";
          parts.push(`Connection: ${conn.effectiveType} (${downlink} Mbps)`);
        } else {
          parts.push(`Connection: ðŸ¤·`);
        }

        // Add local IPs (best-effort; may be empty or suppressed by the browser)
        try {
          const local = await getLocalIPs();
          if (local && local.length)
            parts.push(`Local IPs: ${local.join(", ")}`);
        } catch (e) {}

        // Try public IP + reverse DNS (best-effort)
        try {
          const publicIp = await getPublicIP();
          if (publicIp) {
            const host = await reverseDNS(publicIp);
            if (host) parts.push(host);
            else parts.push(`Public IP: ${publicIp}`);
          }
        } catch (e) {}

        connectionEl.textContent = parts.join(" â€¢ ");
      }

      // Ping using fetch + AbortController for reliable timing and timeouts.
      // Using `mode: 'no-cors'` so cross-origin endpoints (like generate_204)
      // can be requested without CORS preflight; we only care about timing.
      function pingImage(url, timeout) {
        return new Promise(async (resolve, reject) => {
          const controller = new AbortController();
          const signal = controller.signal;
          const start = performance.now();
          const timer = setTimeout(() => {
            controller.abort();
          }, timeout);

          // Add cache-buster to avoid cached responses
          const sep = url.includes("?") ? "&" : "?";
          const u = url + sep + "_cache=" + Date.now();

          try {
            // `no-cors` makes the response opaque but the fetch promise still
            // resolves when the request completes. This gives a reliable timing
            // measurement for reachability and latency.
            await fetch(u, {
              method: "GET",
              mode: "no-cors",
              cache: "no-store",
              signal,
            });
            clearTimeout(timer);
            resolve(performance.now() - start);
          } catch (e) {
            clearTimeout(timer);
            if (e && e.name === "AbortError") reject(new Error("timeout"));
            else reject(new Error("error"));
          }
        });
      }

      function addSample(value) {
        history.push(value);
        if (history.length > MAX_HISTORY) history.shift();
        renderStats();
        drawChart();
      }

      function renderStats() {
        const attempts = history.length;
        const successes = history.filter((v) => typeof v === "number");
        const failures = attempts - successes.length;

        const timeouts = history.filter((v) => v === "timeout").length;
        const errors = history.filter((v) => v === "error").length;

        lastEl.textContent = successes.length
          ? `${Math.round(successes[successes.length - 1])} ms`
          : "â€” ms";
        if (successes.length) {
          const min = Math.round(Math.min(...successes));
          const max = Math.round(Math.max(...successes));
          const avg = Math.round(
            successes.reduce((a, b) => a + b, 0) / successes.length
          );
          minEl.textContent = `${min} ms`;
          maxEl.textContent = `${max} ms`;
          avgEl.textContent = `${avg} ms`;
          // jitter: mean absolute difference between consecutive successes
          let diffs = 0,
            count = 0;
          for (let i = 1; i < successes.length; i++) {
            diffs += Math.abs(successes[i] - successes[i - 1]);
            count++;
          }
          const jitter = count ? Math.round(diffs / count) : 0;
          jitterEl.textContent = `${jitter} ms`;
        } else {
          minEl.textContent = "â€” ms";
          maxEl.textContent = "â€” ms";
          avgEl.textContent = "â€” ms";
          jitterEl.textContent = "â€” ms";
        }

        const loss = attempts ? Math.round((failures / attempts) * 100) : 0;
        lossEl.textContent = `${loss} %`;
        timeoutsEl.textContent = `${timeouts}`;
        errorsEl.textContent = `${errors}`;
      }

      function drawChart() {
        const w = (canvas.width = canvas.clientWidth * devicePixelRatio);
        const h = (canvas.height = canvas.clientHeight * devicePixelRatio);
        ctx.clearRect(0, 0, w, h);
        ctx.scale(devicePixelRatio, devicePixelRatio);
        const cw = canvas.clientWidth,
          ch = canvas.clientHeight;

        // background
        ctx.fillStyle = "rgba(255,255,255,0.02)";
        roundRect(ctx, 0, 0, cw, ch, 8);
        ctx.fill();

        const samples = history.slice(-MAX_HISTORY);
        const values = samples.filter((v) => typeof v === "number");
        const max = values.length ? Math.max(...values) : 1000;
        const min = values.length ? Math.min(...values) : 0;
        const range = Math.max(1, max - min);

        const padding = 6;
        const plotW = cw - padding * 2;
        const plotH = ch - padding * 2 - 10;

        ctx.beginPath();
        let first = true;
        const step = plotW / Math.max(1, samples.length - 1);
        for (let i = 0; i < samples.length; i++) {
          const x = padding + i * step;
          const v = samples[i];
          let y;
          if (typeof v !== "number") y = padding + plotH;
          else y = padding + (1 - (v - min) / range) * plotH;
          if (first) {
            ctx.moveTo(x, y);
            first = false;
          } else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = "#4fd1c5";
        ctx.lineWidth = 2;
        ctx.stroke();

        // draw failure markers (timeout vs error)
        for (let i = 0; i < samples.length; i++) {
          if (typeof samples[i] !== "number") {
            const x = padding + i * step;
            const y = padding + plotH;
            const v = samples[i];
            // timeout: orange-ish, error: red
            if (v === "timeout") ctx.fillStyle = "rgba(255,181,107,0.95)";
            else ctx.fillStyle = "rgba(255,107,107,0.95)";
            ctx.beginPath();
            ctx.arc(x, y - 6, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      function roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
      }

      async function singlePing() {
        const url = (targetEl.value || "").trim();
        if (!url) return null;
        const timeout = Math.max(50, Number(timeoutEl.value) || 3000);
        try {
          const ms = await pingImage(url, timeout);
          return ms;
        } catch (e) {
          // return a typed failure so UI can distinguish timeouts vs other errors
          if (e && e.message === "timeout") return "timeout";
          return "error"; // treat other errors as generic errors
        }
      }

      async function loopPing() {
        if (!running) return;
        updateConnectionInfo();
        // indicate we're performing a ping
        setActivity("pending");
        const res = await singlePing();
        addSample(res);
        // show brief success / failure feedback
        if (typeof res === "number") setActivity("success");
        else if (res === "timeout") setActivity("timeout");
        else setActivity("error");
        const interval = Math.max(100, Number(intervalEl.value) || 2000);
        timer = setTimeout(loopPing, interval);
      }

      startBtn.addEventListener("click", () => {
        if (running) {
          running = false;
          startBtn.textContent = "Start";
          if (timer) clearTimeout(timer);
          setActivity();
          return;
        }
        // start
        history.length = 0;
        renderStats();
        drawChart();
        running = true;
        startBtn.textContent = "Stop";
        loopPing();
      });

      clearBtn.addEventListener("click", () => {
        history.length = 0;
        renderStats();
        drawChart();
      });

      // initial draw
      renderStats();
      drawChart();
      updateConnectionInfo();
      // keep connection info updated if available
      const nav = navigator;
      const conn = nav.connection || nav.mozConnection || nav.webkitConnection;
      if (conn && conn.addEventListener) {
        conn.addEventListener("change", updateConnectionInfo);
      }

      // resize handling
      let resizeTO;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTO);
        resizeTO = setTimeout(() => drawChart(), 120);
      });
    </script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
      // Map and geolocation tracking
      (function () {
        if (!window.L) return; // Leaflet not loaded

        const mapEl = document.getElementById("map");
        if (!mapEl) return;

        const map = L.map("map", { zoomControl: true }).setView([0, 0], 2);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 19,
          attribution:
            '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a>',
        }).addTo(map);

        const trackLayer = L.layerGroup().addTo(map);
        let lastPos = null;
        let currentMarker = null;
        let watchId = null;

        function colorForState(state) {
          switch (state) {
            case "pending":
              return "#4fd1c5"; // accent
            case "success":
              return "#4cf9b8"; // green
            case "timeout":
              return "#ffb56b"; // orange
            case "error":
              return "#ff6b6b"; // red
            default:
              return "#9aa6b2"; // muted/idle
          }
        }

        function onPosition(pos) {
          const latlng = [pos.coords.latitude, pos.coords.longitude];
          const state = lastActivityState || null;
          // draw segment from lastPos -> latlng with color representing the current activity
          if (lastPos) {
            const seg = L.polyline([lastPos, latlng], {
              color: colorForState(state),
              weight: 4,
              opacity: 0.9,
            }).addTo(trackLayer);
          }
          // update current marker
          if (!currentMarker) {
            currentMarker = L.circleMarker(latlng, {
              radius: 6,
              fillColor: colorForState(state),
              color: "#000",
              weight: 0.5,
              fillOpacity: 0.95,
            }).addTo(trackLayer);
            map.setView(latlng, 14);
          } else {
            currentMarker.setLatLng(latlng);
            currentMarker.setStyle({ fillColor: colorForState(state) });
          }
          lastPos = latlng;
        }

        function onPosError(err) {
          // ignore; the map can remain static if location is unavailable
          console.warn("Geolocation error", err && err.message);
        }

        // Start/stop watch tied to the pinging start/stop
        const origStartClick = startBtn.onclick;
        function startGeolocation() {
          if (!navigator.geolocation) return;
          if (watchId != null) return;
          watchId = navigator.geolocation.watchPosition(
            onPosition,
            onPosError,
            {
              enableHighAccuracy: true,
              maximumAge: 5000,
              timeout: 10000,
            }
          );
        }

        function stopGeolocation() {
          if (watchId != null && navigator.geolocation) {
            navigator.geolocation.clearWatch(watchId);
            watchId = null;
          }
        }

        // Hook into the start button logic: when running starts, start geolocation; when stopped, stop it.
        const orig = startBtn.onclick; // may be null; we also observe clicks below
        startBtn.addEventListener("click", () => {
          // determine running state by button text (Start vs Stop) and `running` flag
          setTimeout(() => {
            if (running) startGeolocation();
            else stopGeolocation();
          }, 50);
        });

        // Also start geolocation if ping loop started programmatically
        const originalLoopPing = window.loopPing;
        // no-op: we don't override loopPing here; start is handled by click listener above
      })();
    </script>
    <script>
      // Register service worker for PWA (best-effort)
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/sw.js")
            .then((reg) => {
              console.log("Service worker registered", reg);
            })
            .catch((err) => console.warn("SW registration failed", err));
        });
      }
    </script>
  </body>
</html>
